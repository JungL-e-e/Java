6-1 객체 지향 프로그래밍

객체란? 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것.
	ex) 자동차, 자전거, 책, 사람, 강의, 주문 모두 객체가 될 수 있다.

객체	- 1. 속성 (필드)
	- 2. 동작 (메소드)

* 객체들은 다른 객체와 서로 상호작용하면서 동작한다.(상호작용 수단은 메소드)
	ex)	메소드(매개값1, 매개값2, ...);

* 객체 간의 관계
	1. 집합 관계 - 완성품과 부품의 관계 	ex) 자동차는 엔진, 타이어, 핸들 등으로 구성
	2. 사용 관계 - 다른 객체의 필드를 읽고 변경하거나 호출하는 관계 ex) 사람과 자동차
	3. 상속 관계 - 부모 자식 관계 ex) 자동차가 기계의 특징을 물려받으면 기계는 자동차와 상속 관계

* 객체 지향 프로그래밍의 특징
	1. 캡슐화 - 필드와 메소드를 묶고 구현 내용을 외부의 감추는 것
	2. 상속	- 부모 객체의 특징을 자식 개체가 사용 가능
		* 상속을 하면 코드의 재사용성을 높여줌.
		* 유지 보수 시간을 최소화 시킨다.
	3. 다형성 - 사용 방법은 동일하지만 결과가 다양하게 나오는 성질
		* 자동차 부품을 바꾸면 성능이 바뀜.



6-2 객체와 클래스

인스턴스 - 클래스로부터 생성된 객체
	ex) 설계도로 만들어진 자동차가 인스턴스


6-3 클래스 선언

클래스 선언은 객체 생성을 위한 설계도를 작성하는 작업
Ex)	public class 클래스먕 {
	}
	* 클래스명은 대문자 시작, 첫문자 숫자 x, _와$ 사용가능

* public class 는 어느 위치에 있든지 패키지와 상관없이 사용할 수 있는 클래스 (공개클래스)
* 공개클래스를 여러개 생성하려면 소스 파일을 별도로 생성해야 한다.



6-4 객체 생성과 클래스 변수

클래스로부터 객체를 생성하려면 new 연산자가 필요하다.
Ex)	클래스 변수 = new 클래스();
	Student s1 = new Student();

클래스 - 라이브러리 클래스: 실행할 수 없으며 다른 클래스에서 이용하는 클래스
     - 실행클래스: main() 메소드를 가지고 있는 실행 가능한 클래스


6-5 클래스 구성 멤버

1. 필드  - 객체의 데이터를 저장하는 역할. (변수 선언과 비슷하지만 쓰임새는 다름)
2. 생성자	- new 연산자로 객체를 생성할 때 객체의 초기화 역할 담당
3. 메소드 - 객체가 수행할 동작(함수라고도 불림)


6-6 필드 선언과 사용

타입 필드명 [ = 초기값];



6-7 생성자 선언과 호출

Ex)	Car myCar = new Car(); *기본 생성자 호출

* 기본 생성자 - 모든 클래스는 생성자가 존재하며, 하나 이상을 가질 수 있다. 클래스에 생성자 선언이 없으면, 컴파일러는 기본 생성자를 추가한다.

생성자 선언
Ex)	Car(String model, String color, int maxspeed) {
	}

필드 초기화 - 공통된 값이면 값을 선언해주지만, 객체마다 다른 값이면 초기화시켜준다.

* 생성자 안에서의 매개값과 필드에 선언된 필드명이 같을때 헷갈리지 않도록 this. 키워드를 붙여준다. 
* this. 키워드는 객체의 데이터(필드)로서의 name을 뜻한다.
* 예시 참고

생성자 오버로딩 - 매개값으로 객체의 필드를 다양하게 초기화할때 사용
Ex)	Car() {}
	Car(String model) {...}
	car(String model, String color) {...}
* 매개변수의 위치를 바꾸는 것은 해당되지 않는다.

다른 생성자 호출 - 공통 코드를 가지고 있는 한 생성자만 집중적으로 작성하면 나머지는 this(...)사용가능
Ex)	Car{String model, String color, int maxspeed) {
	this.mode = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
	}

	Car(String model, String color) {
	this(model, color, 250);
	}

	Car(String model) {
	this(model, "은색", 250);
	}



6-8 메소드 선언과 호출

*	리턴타입 메소드명 (매개변수, ...) {
		실행할 코드
	}

1. 리턴타입 
	void: 리턴값이 없음
	double: double 타입 값을 리턴하는 메소드

2. 메소드명
	캐멀 스타일로 작성

3. 매개변수
	
4. 실행 블록

5. 메소드 호출
Ex)	Calculator calc = new Calculator();
	calc.powerOn();
	int y1 = calc.plus(3,5);

6. 가변길이 매개변수
 메소드를 호출할 때에는 매개변수의 개수에 맞게 매개값을 제공해야하지만, 가변길이 매개변수를 가지고있으면 매개변수의 개수와 상관없이 매개값을 줄 수 있다.
Ex)	int sum(int ... values) {
		int sum = 0;
		for (int i = 0, i < values.length; i++) {
			sum += values[i];
		}
		return sum;
	}
 * 예시 참고

7. return 문
* 메소드의 실행을 강제 종료하고 호출한 곳으로 돌아간다는 의미
* 메소드 선언에 리턴 타입이 있을 경우에는 return 문 뒤에 리턴값을 정해야한다.
* return 뒤에는 어느 문장도 올 수 없다.

8. 메소드 오버로딩
 메소드 이름은 같되 매개변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것



6-9 인스턴스 멤버
필드와 메소드는 선언 방법에 따라 인스턴스 멤버와 정적멤버로 분유
1. 인스턴스 멤버 - 객체를 생성해야 사용가능
2. 정적 멤버(static) - 객체 없이도 사용가능

*인스턴스 멤버는 new연산자로 객체를 미리 생성한다음, 참조 변수로 접근해서 사용해야 한다.

this 키워드 - this는 객체 자신을 this 라고 하며, 필드명을 강조하고자할때 사용한다.



6-10 정적 멤버
* 정적멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버
* 객체 생성 없이 바로 사용 가능

1. 정적 멤버 선언
ex)	static 타입필드 = 초기값;
	static 리턴타입 메소드(매개변수, ...) {
	}

* 인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다.

2. 정적 멤버 사용
ex)	static double pi = 3.141592;
	static int plus(int x, int y) {...}
* 정적필드와 정적 메소드는 객체 참조 변수로도 접근 가능
ex)	double result1 = 10 * 10 * myCalcu.pi;

3. 정적 블록
* 복잡한 초기화 작업이 필요하다면 정적 블록 이용
ex)	static String info = "LCD"; 이렇게 초기화값을 작성해줘야하지만 단순식이 아니라 복잡한 연산식이면 
					초기화를 바로 시켜주지 않고 스태틱 블록안에 연산식을 넣어준다.
	Static {
		info = company + "-" + model;	//처럼 블록을 사용하여 작성한다.
	}	

4. 인스턴스 멤버 사용 불가
 * 정적블록 안에는 인스턴스 메소드나 필드를 사용할 수 없다. (this포함)
 * 하지만 정적블록이나 메소드 자체 안에 객체를 새로 생성하면 인스턴스 메소드나 필드를 사용할 수 있다.
 * main()에도 똑같이 적용된다!



6-11 final 필드와 상수
* 인스턴스와 스태틱은 모두 값을 변경가능하다. 하지만 아예 변경이 불가능하게 선언하려면 final을 사용한다.
ex)	final 타입 필드 (=초기값);
* final 필드에 초기값을 줄 수 있는 방법은, 필드 선언시와 생성자에서 초기값을 대입하는 것 뿐이다.

1. 상수 선언
* 불변의 값 (ex 원주율, 지구 무게등)을 상수하고 부른다. 상수는 다음과 같이 선언한다.
ex)	static final 타입 상수 (=초기값);
	static final double PI = 3.141592;
* 추가적으로 상수가 복잡한 연산식일 경우 정적 블록도 사용 가능하다.



6-12 패키지
* 단순히 디렉토리가 아닌, 클래스 식별 용도로 사용
* 컴파일할때 인위적으로 수정하면 작동이 안된다.
* 패키지 선언이 없으면 default package에 포합시킨다.

1. import 문
* 다른 패키지에 있는 클래스를 사용하기위해 사용
* 여러 패키지를 import 했는데 같은 클래스가 있을경우 컴파일 오류가 뜬다.
* 이경우에는 패키지이름까지 앞에 붙여준다
ex)	com.hankkok.Tire tire = new com.hankkok.Tire(); //안중요해 이럴 일 없음.



6-13 접근 제한자
* 외부의 호출을 조절할때 사용
	1. public	클래스, 필드, 생성자, 메소드	제한 범위 없음
	2. protected	필드, 생성자, 메소드		같은 패키지, 자식 객체
	3. (default)	클래스, 필드, 생성자, 메소드	같은 패키지	// 접근제한자가 붙어있지 않은 상태
	4. private	필드, 생성자, 메소드		객체 내부

2. 생성자
	1. public	모든 패키지
	2. (default)	같은 패키지
	3. private	클래스 내부

3. 필드와 메소드도 생성자와 동일



6-14 Getter, Setter
 * 메소드에서 데이터를 검증해서 유효값만 필드에 저장하는 메소드 = Setter * 검열하는거
 * 필드값이 객체 외부에서 사용하기 부적절할 경우, 적절한 값으로 변환해서 리턴하는 메소드 = Getter * 외부에서 데이터 얻는거
 * 데이터를 직접 적으로 넣지를 못하므로 퍼블릭 메소드를 이용하여 getter와 setter로 값을 지정 및 부를 수 있다. 이때 메소드로 
	추가적인 조건을 달아서 이상한 값을 못넣게 정하는 용도로 사용한다.
 * boolean Getter 는 get이 아닌 is로 시작하는 것이 관례
 * 공부 필요



6-15 싱글톤 패턴
 * 애플리케이션 전체에서 단 한 개의 객체만 생성해서 사용하고 싶을때 사용
 * private 접근 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것
 * private 필드 생성으로 객체를 하나 만든뒤에 생성자도 private로 만들어 접근을 불가능하게 하고, public static getInstance() 메소드로 객체 하나 생성된것만 부르는 용도로 사용

대충 다 이해해쓰!