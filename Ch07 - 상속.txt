7-1 상속 개념 / 7-2 클래스 상속
* 상속은 부모가 자식에게 물려주는 행동
자식 클래스가 부모를 지정하여 상속함.
부모 클래스의 있는 필드와 메소드를 중복하여 작성하고 싶지 않을때 자식클래스에서 부모 클래스를 가져옴

ex)	public class 자식클래스 extends 부모클래스 {
	}

	public class B extends A {			// B 가 A 를 상속하여 가져옴
		String field2;
		void method2() { ... }
	}

* c++ 같은경우에는 다중으로 부모클래스를 상속할 수 있지만, 자바는 오로지 한개의 부모만 상속가능



7-3 부모 생성자 호출
* 자식 객체를 생성하면, 눈에는 안보이지만 부모 클래스에서도 객체를 생성 후 자식객체를 만든 것

* 자식 생성자의 첫줄에는 super() 이 숨겨져있는데, 이 함수의 뜻은 부모 생성자를 실행한다는 뜻이다.
* 그러므로 자식생성자가 실행되면 바로 부모생성자가 만들어지고 그 이후에, 자식 생성자가 만들어진다.
* super()은 자동으로 컴파일되고 생략도 가능하다. + 맨 앞줄에 적어야만 한다.

* 만약 부모생성자에게 매개변수가 들어간다면, 자식생성자에 super() 은 자동으로 컴파일 오류가 생성된다.
	따라서 super(매개변수1, 매개변수2); 에 맞게 작성을 해줘야 오류가 생기지 않는다.

ex)	public SamrtPhone(String model, String color) {
		super(model, color);
	}



7-4 메소드 재정의
* 메소드 재정의 (메소드 오버라이딩)은 부모 클래스의 메소드가 고쳐야 될 곳이 있으면 자식 클래스에서 재정의하여 사용하는 것이다.

* 부모 메소드의 선언부(리턴 타입, 메소드 이름, 매개변수)가 동일해야 한다.
* 접근제한을 더 강하게는 불가능
* 예외 처리 throw 불가능 (이후에 배움)

* 메소드 위에 @Override (Annotation)을 작성하면 컴파일러가 이 메소드가 제대로 오버라이딩 됐는지 확인해준다.
* 재정의 이므로 자식메소드에 부모메소드 내용을 모두 다시 적어줘야한다.
* 내용을 모두 다시 적는게 맞지만, 자식메소드에서 무언가를 부모메소드에서 추가만 마지막에 해주는거면
super.method(); 를 사용해주면 그 내용을 그대로 가져온다.



7-5 final 클래스, final 메소드
* final 뜻은 수정 	불가기 때문에 final 클래스는 상속이 불가하다.
* final 메소드 또한 자식 메소드에서 오버라이딩이 불가능하다.



7-6 protected 접근 제한자
* public 과 default 사이에 protected 접근 제한자가 있는데, 클래스를 제외한 필드 메소드 생성자에 붙일 수 있다.
* protected 는 같은 패키지에선느 접근이 가능하다, 다른 패키지에서는 자식 클래스만 접근을 허용한다.
* 대신 직접 객체를 생성해서 사용하는 것은 안된다. 상속을 통해서만 가능



***** 중요!!! 7-7 타입 변환
* 부모 클래스는 자식 클래스보다 큰 개념이기 때문에
	부모타입 변수 = 자식 타입 객체; 가 가능하다.
ex)	Aniaml animal = new Dog(); 	//animal 과 dog는 같은 객체의 번지를 가져온다

	== Dog dog = new Dog();
	   Animal animal = dog;

* 부모타입으로 형변환을 했으면 부모타입의 메소드만 호출이 가능하다 (대신에 메소드 오버라이딩 되어있으면 자식타입 메소드에서 가져온다)
	* 이것은 다형성과 관련이 있기때문에 매우 중요하다.


2. 강제 타입 변환
* 자식타입에서 부모타입으로는 자동 변환되지만, 부모타입에서 자식타입으로는 캐스팅 연산자로 강제 타입 변환해야한다.
	Parent parent = new Child();
	Child child = (Child)parent;
* 자식객체가 여러개 일때 자식에서 부모, 다시 자식으로 갈때 같은 객체로만 돌아 올 수 있다. (다른 자식객체는 안됨)
* 기본적으로 부모에서 자식으로는 못가지만 자식이 부모타입으로 자동변환 된 객체라면 강제 타입 변환이 가능하다.



7-8 다형성
* 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
* 자동 타입 변환 + 메소드 재정의 = 다형성
* 자동 타입 변환은 자식 클래스가 부모 클래스로도 자동으로 변환가능하다 라는것을 의미하고, 재정의는 자식타입 클래스에서 메소드를 덮어 씌울 수 있는 것이다. 따라서 여러개의 성능이 다른 자식을 메소드 재정의로 만들고 자동타입 변환으로 하면 성능이 다른 자식들을 원하는 상황에 부모클래스에 정의시켜 사용 할 수 있다.

1. 필드 다형성
* 필드에 클래스가 선언됐을떄, 그 클래스의 자식클래스도 다형성으로 만들 수 있다.

2. 매개변수 다형성
* 메소드의 매개변수에도 클래스가 들어 갈 수 있는데, 그때 그 클래스의 자식클래스도 들어가서 다형성 만들 수 있다.

______________________________________________________________________________________________________________________________

다형성 내가 이해한 것들

1. 다형성은 자동변환과 메소드 오버라이딩을 합쳐서 만든 것이다.

2. 자동변환은 자식 객체를 이용해 부모 클래스로 선언한 것이다.
	ex)	Class Parent {
		}
		Class Child extends Parent {
		}

		Parent obj1 = new Child();
		* 자식 객체는 부모객체로부터 상속을 받고 그 특징들을 모두 가져오기 때문에 자동변환이 가능하다.

3. 메소드 오버라이딩은 부모와 자식 클래스 사이에서 부모클래스의 있는 메소드를 원하는대로 변형시키고 싶으면
   자식클래스에 부모클래스의 리턴타입, 이름, 매개변수를 똑같이 선언하여 변형시키면 부모 클래스의 메소드가 아닌 자식 클래스의 메소드로 실행된다.

4. 이 두개를 합치면 선언은 Parent 클래스로 하지만, 자식객체를 각각 다르게 하여 메소드 오버라이딩을 각각시키면 원하는대로 실행을 시킬 수 있다.
	ex)	Class Parent {
			public void method1() {};
			
		}
		Class Child1 extends Parent {
			public void method1() {변형1};
		}
		Class Child2 extends Parent {
			public void method1() {변형2};
		}

		Parent obj1 = new Child1();
		Parent obj2 = new Child2();
		obj1.method1();	// 서로 다른 변형된 메소드가 실행된다. (변형1)
		obj2.method1();	// 서로 다른 변형된 메소드가 실행된다. (변형2)

		* 대신 부모객체로 자동변환하면 부모객체의 있는 메소드나 특징만 쓸 수 있다
		* 그중에서 오버라이딩된 자식객체를 가져오는 개념으로 다형성을 구현한 것이다.

______________________________________________________________________________________________________________________________
7-9 객체 타입 확인

* instances 연산자는 보통 강제타입변환을 하기 전에 가능한지 조건문을 만들기위해 사용한다.
* 강제타입은 이미 자동변환으로 자식이 부모로 바뀌었을때에만 사용이 가능하기 때문이다
Ex)	boolean result = 객체 instanceof 타입;
	boolean result = parent instanceof child;

	public void method(Parent parent) {
		if (parent instanceof Child) {
			Child child = (child) parent;
		}
	}


*최신버전		if(parent instanceof Child child) {
		}




7-10 추상클래스
* 각 클래스마다 공통된 필드나 메소드가 있으면 그것을 묶어서 새로운 부모 클래스를 만들어 중복으로 쓸 필요없이 만드는 것이 추상클래스이다.

* 직접 사용하지는 않지만 공통된 것을 묶기위한 용도 (객체를 직접 만들지는 못함)

2. 추상 메소드와 재정의
* 공통된 메소드지만 (공통된 것은 맞지만) 내용은 같지 않은 것들은 메소드 재정의를 이용하여 사용된다.
Ex)	abstract 리턴타입 메소드면(매개변수, ...); 
	* 메소드의 실행 내용인 {} 중괄호가 없다. (그냥 메소드 재정의를 위한 선언용)

	public abstract class Animal {
		abstract void sound();
	}



7-11 봉인된 클래스
* sealed class	- final class	는 자식 클래스 자체를 가질 수 없지만, 봉인된 클래스는 몇몇 클래스만 허용하여 자식클래스를 가질 수 있다.

Ex)	public sealed class Person permits Employee, Manager {		// permits 을 사용하여 자식클래스를
	}								// 허용해줌 

	* Employee 와 Manager 클래스는 부모가 봉인된 클래스여서 자식들도 final 또는 non-sealed 클래스를 붙여야한다.
	1. final - 더이상 자식클래스 안만듬
	2. non-sealed - 봉인을 해제함
							
